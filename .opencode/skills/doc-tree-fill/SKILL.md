---
name: doc-tree-fill
description: 根据文档树规划，在指定目录下逐子文档生成大纲并填充内容，最后生成入口导航文档（index.md）。由 /create 命令在用户选择"多文件文档树"创建形式后调用
---

# doc-tree-fill

> **Skill ID**：`doc-tree-fill`
> **版本**：1.0.0
> **类型**：instruction
> **用途**：接收文档树规划，在 `base_dir` 下创建多个子文档并逐一填充，最后生成导航入口文档（index.md）

---

## 触发条件

本 Skill 由 `/create` 命令在用户选择"多文件文档树"创建形式后内部调用，不直接面向用户触发。

---

## 输入

| 参数 | 必需 | 说明 |
|------|:----:|------|
| `tree_plan` | 是 | 文档树规划，来自 `doc-outline-generate` 输出的"建议的文档树结构"部分：包含目录结构描述、各子文档的文件名、标题、覆盖章节、预估行数 |
| `base_dir` | 是 | 子文档的存放目录，如 `docs/cross-platform-setup/`；该目录即为文档树的根 |
| `original_idea` | 是 | 原始文档想法（含 `/create` 阶段 0.5 汇总的 `enriched_context`），用于为每个子文档生成准确的大纲 |
| `materials` | 否 | 用户提供的素材：背景资料、数据、代码片段等 |
| `constraints` | 否 | 额外约束：语言风格、目标受众、各子文档的长度要求等 |
| `max_lines_per_doc` | 否 | 每个子文档的行数上限，默认 `300` |

---

## 执行步骤

> **交互原则**：所有需要向用户提问或确认的步骤，**必须使用 `question` 工具**进行交互，不得直接输出文本等待用户回复。

### 步骤 1：解析文档树规划并初始化

1. 从 `tree_plan` 中提取子文档列表，每个子文档包含：
   - `filename`：文件名（如 `database-design.md`）
   - `title`：子文档标题
   - `chapters`：覆盖的原始大纲章节（逗号分隔的章节名列表）
   - `estimated_lines`：预估行数
2. 将 `index.md`（入口导航文档）**移至列表末尾**处理（需等所有子文档完成后才能生成准确导航）
3. 检查 `base_dir` 是否存在：
   - 不存在：使用工具创建该目录，输出：`📁 已创建目录：{base_dir}`
   - 已存在：直接使用，检查目录中是否有同名文件，若有则告知用户
4. 输出执行计划预告：
   ```
   📋 文档树创建计划
   目录：{base_dir}
   子文档数量：{N} 个（含入口导航文档）
   预估总行数：~{总行数} 行

   创建顺序：
   1. {filename} — {title}（~{estimated_lines} 行）
   2. {filename} — {title}（~{estimated_lines} 行）
   ...
   最后. index.md — 导航入口文档
   ```

---

### 步骤 2：逐子文档创建与填充

对列表中每个子文档（`index.md` 除外），**依次**执行以下操作：

#### 2.1 生成子文档大纲

加载 `doc-outline-generate` Skill，传入：

- `idea`：`original_idea` 中与当前子文档相关的部分 + 当前子文档的聚焦范围描述：
  > 本子文档聚焦于以下章节：{chapters}。请仅为这些章节生成详细大纲，不涉及其他模块。
- `extra_constraints`：`constraints` + `"本文档预期行数控制在 {max_lines_per_doc} 行以内"`
- `output_file`：`{base_dir}/{filename}`

此步骤将子文档大纲写入文件，规模评估中"建议形式"此时应为"单文件"（因为范围已被聚焦）。

#### 2.2 填充子文档内容

加载 `doc-content-fill` Skill，传入：

- `output_file`：`{base_dir}/{filename}`
- `materials`：`materials`（全量传入，Skill 自动筛选与本文档范围相关的素材）
- `constraints`：`constraints`
- `max_lines`：`max_lines_per_doc`

**填充完成后，记录该子文档的实际行数和摘要（供后续生成 index.md 使用）**。

输出进度：
```
[{当前序号}/{子文档总数}] ✅ {filename}（{title}）— 共 {actual_lines} 行
```

---

### 步骤 3：生成入口导航文档（index.md）

所有子文档填充完成后，在 `{base_dir}/index.md` 创建导航入口文档。

**入口文档格式**：

```markdown
# {文档树主标题}

> **文档类型**：多文档集合（导航入口）
> **日期**：{当前日期}
> **版本**：1.0.0
> **状态**：草稿

---

## 概述

{2-3 句话描述本文档集合的主题、目的和覆盖范围，基于 original_idea}

---

## 文档目录

| 文档 | 说明 | 预估阅读时间 |
|------|------|------------|
| [{title}](./{filename}) | {一句话说明该子文档核心内容} | ~{minutes} 分钟 |
| ... | ... | ... |

---

## 内容导览

### [{sub-doc-1 title}](./{sub-doc-1-filename})

{2-3 句话摘要，描述该子文档的核心内容和阅读价值}

### [{sub-doc-2 title}](./{sub-doc-2-filename})

{2-3 句话摘要}

（其余子文档依次列出）

---

*本文档集合由 `/create` 命令以多文件文档树形式创建于 {日期}。如需调整结构，使用 `/evolve`。*
```

使用 **`write` 工具**将入口文档内容写入 `{base_dir}/index.md`，写入后输出：

```
✅ 导航入口文档已生成：{base_dir}/index.md
```

---

### 步骤 4：输出完成摘要

```
---

文档树创建完成！

📁 **目录**：{base_dir}

📄 **文件清单**：
1. {filename}（{actual_lines} 行）— {title}
2. {filename}（{actual_lines} 行）— {title}
...
N. index.md — 导航入口文档

📊 **总行数**：~{总行数} 行（{N} 个子文档 + 1 个导航文档）

---
```

---

## 各子文档间的一致性原则

多个子文档共同构成一个知识体系，填充时需保证：

1. **术语统一**：各子文档使用相同的专业术语，不同文档对同一概念的描述应一致
2. **不重复**：不同子文档间不复制内容；如有交叉，通过链接引用（如 `详见 [数据库设计](./database-design.md) 章节`）
3. **可独立阅读**：每个子文档开头提供必要的背景上下文，让读者无需阅读其他子文档也能理解
4. **引用准确**：子文档间的相对路径链接使用 `./filename.md` 格式，不使用绝对路径

---

## 缺失信息处理

| 场景 | 处理方式 |
|------|---------|
| `tree_plan` 缺失 | 无法执行，提示调用方传入 `doc-outline-generate` 生成的文档树规划 |
| `base_dir` 缺失 | 使用 `question` 工具请求用户指定目录路径 |
| 某个子文档 `doc-outline-generate` 阶段大纲为空或异常 | 跳过该子文档的填充，在摘要中标注"大纲异常，需手动处理" |
| 某个子文档填充后超出 `max_lines_per_doc` | 在摘要中标注超长警告，建议后续使用 `/evolve` 进一步拆分 |
| `original_idea` 未提供 | 仅使用 tree_plan 中的章节范围描述生成大纲，信心等级可能降低 |

---

## 质量标准

- [ ] 所有子文档均已创建并填充，无遗漏
- [ ] 每个子文档行数在 `max_lines_per_doc` 范围内（允许 ±10% 弹性）
- [ ] 入口导航文档包含所有子文档的链接和摘要，链接路径正确
- [ ] 各子文档间无内容重复，交叉内容通过链接引用
- [ ] 子文档标题与导航入口中的链接文字一致
- [ ] 每个子文档开头有足够的背景上下文，可独立阅读
