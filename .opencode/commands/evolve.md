---
name: evolve
description: 以整个文档库为单位进行演进——读取所有文档全文，构建跨文档知识图谱，分析方向对齐度/概念一致性/覆盖缺口，生成结构操作与内容操作并行的整体变更计划，确认后执行并更新 index.md。
---

# /evolve 命令

> **命令**：`/evolve`
> **版本**：2.0.0
> **用途**：以**整个文档库**为单位进行演进——不是修补单个文档，而是从全局视角重新对齐知识体系、传播方向变化、填补覆盖缺口、同步概念定义、清理结构债务。

---

## 用法

```
/evolve <演进意图>
```

**示例**：

```
/evolve 我现在转向研究分布式一致性协议，之前的组件平台设计暂时搁置
/evolve 全面梳理一遍文档库，消除不一致，让所有文档对齐当前方向
/evolve 把 infrastructure/ 下的文档重新按"数据/能力/视图"三大支柱分类
/evolve 扩充文档库，把现在方向的覆盖缺口都填上
/evolve 清理断裂引用和孤立文档
```

---

## 核心理念

> `/evolve` 将文档库视为**活的知识图谱**，而非静态文件集合。每次演进：
>
> - **读懂每篇文档的真实内容**，而非只看文件名和标题
> - **理解文档间的概念依赖与方向对齐**，找到全库的薄弱环节
> - **以"知识连贯性"为标准驱动变更**，而非仅靠文件大小/位置判断
> - **全库联动**：一个方向变化可能需要更新十篇文档的内容

---

## 交互原则

> **重要**：所有需要向用户提问或确认的步骤，**必须使用 `question` 工具**进行交互，而非直接输出文本等待用户回复。
>
> **确认优先**：所有文件操作前必须展示完整变更计划并获得用户确认，不得自动执行。

---

## 执行流程

### 阶段 0：获取演进意图

1. 从 `/evolve` 命令参数提取用户的演进意图
2. 若用户未提供意图（直接输入 `/evolve` 无参数），使用 `question` 工具提问：
   - **问题**：你希望如何演进文档库？
   - **选项**：
     1. 传播方向变化（当前探索方向已转变，全库对齐新方向）
     2. 重新组织结构（重新分类、拆分超长、合并碎片）
     3. 填补知识缺口（根据当前方向，补充缺失文档）
     4. 同步概念定义（修正跨文档的术语不一致）
     5. 清理技术债务（孤立文档、断裂引用、过时内容）

   收到回答后，使用 `question` 工具追问具体细节（如新方向是什么、哪些概念需要统一等）。

---

### 阶段 1：全库深度扫描

**步骤 1.1：递归扫描文件元数据**

扫描 `docs/` 下所有 `.md` 文件（含 `_archive/`），对每个文件收集：

- **路径**：相对于项目根目录的路径
- **行数**：文件总行数
- **H1 标题**：文件第一个 `#` 标题
- **所有 H2 标题**：章节结构概览（`##` 级别）
- **引用关系**：
  - `references`：本文件中链接到的其他 `docs/` 文件
  - `referenced_by`：其他文件中链接到本文件的列表

**步骤 1.2：读取所有文档全文**

逐一读取每个 `.md` 文件的**完整内容**，构建全文映射：

```
doc_contents = { "docs/vision/overview.md": "<full content>", ... }
```

> **注意**：如文档数量极多（>30 篇），对行数 < 100 的文档读取全文，对超长文档读取每个 H2 章节的首段。

**步骤 1.3：提取库级知识特征**

基于全文内容，提取：

- **核心概念清单**：各文档中定义或频繁使用的关键术语（如"Intent 协议"、"数据总线"、"能力总线"）
- **方向对齐度**：每篇文档与 `index.md` "当前探索方向"的对齐情况（高/中/低/偏离）
- **概念一致性**：同一术语在不同文档中是否定义一致；识别矛盾表述
- **内容陈旧度**：文档是否引用了已归档/废弃的方案，或与当前方向明显脱节

**步骤 1.4：生成结构诊断**

- **超长文档**：行数 > 300 的文件列表
- **孤立文档**：未被任何文档（含 index.md）引用的文件
- **断裂引用**：引用了不存在文件的链接列表
- **未收录文档**：存在于 `docs/` 但未出现在 `index.md` 中的文件

**步骤 1.5：读取当前 index.md**

读取 `docs/index.md` 全文，提取"当前探索方向"声明，作为全库基准方向和对齐基准。

**步骤 1.6：输出扫描摘要**

```
---
docs/ 深度扫描完成

文档总数：{N} 篇 / 总行数：{N} 行

📐 方向对齐度：
  高度对齐：{N} 篇
  部分对齐：{N} 篇
  方向偏离/陈旧：{N} 篇（{文件列表}）

🔤 概念不一致：{N} 处（{概念名列表}或"无"}）
📋 超长文档（>300 行）：{列表或"无"}
🔗 孤立文档：{列表或"无"}
❌ 断裂引用：{列表或"无"}
📌 未收录文档：{列表或"无"}
---
```

---

### 阶段 2：生成演进方案

**步骤 2.1：调用 `doc-tree-evolve` Skill**

加载 `doc-tree-evolve` Skill，传入以下参数：

- `tree_snapshot`：阶段 1 构建的元数据快照（含 H2 列表、引用关系）
- `doc_contents`：阶段 1 读取的全文内容映射
- `current_index`：当前 `index.md` 全文
- `intent`：阶段 0 获取的用户意图
- `max_lines`：`300`

Skill 输出结构化变更计划，包含操作列表（结构操作 + 内容操作）和新 index.md 草稿。

---

### 阶段 3：展示变更计划并确认

使用 `question` 工具向用户展示完整变更计划并请求确认：

**展示内容**：

1. **全库知识诊断**：方向偏离文档、概念不一致项、覆盖缺口、结构问题
2. **操作列表**：每个操作的类型、目标、原因、风险等级
3. **执行顺序**：操作的先后顺序

**确认交互**：

- **标题**：确认文档库整体演进计划
- **问题**：以上变更计划共 {N} 项操作（结构操作 {N} 项，内容操作 {N} 项）。请选择：
- **选项**：
  1. 确认执行全部操作（Recommended）
  2. 只执行结构操作（跳过内容修改，仅做文件移动/拆分/归档）
  3. 只执行低风险操作（跳过中/高风险操作）
  4. 放弃，不做任何修改

根据用户回应：

- **选择 1（全部执行）**：继续阶段 4，执行所有操作
- **选择 2（仅结构）**：过滤 `UPDATE_SECTION`、`CREATE_FILE`、`SYNC_CONCEPT` 操作，继续阶段 4
- **选择 3（低风险）**：过滤中/高风险操作，继续阶段 4
- **选择 4（放弃）**：输出 `已取消，文档库未做任何修改。` 并终止

---

### 阶段 4：执行变更

按 `doc-tree-evolve` 输出的操作顺序逐条执行：

---

**结构操作**：

**`CREATE_DIR`**：创建目录

```
mkdir -p {path}
```

**`MOVE_FILE`**：移动文件

1. 将文件从 `from` 移动到 `to`
2. 输出：`移动：{from} → {to}`

**`SPLIT_FILE`**：拆分文档

1. 读取源文件内容
2. 按拆分策略（通常按 H2 章节边界）拆分为多个子文件
3. 将子文件写入目标路径
4. 在原文件位置创建导航文件（保留标题 + 链接指向各子文件）
5. 输出：`拆分：{source} → {targets 列表}`

**`MERGE_FILES`**：合并文档

1. 按顺序读取所有源文件
2. 合并内容到目标文件（保持章节结构）
3. 删除源文件（确认后）
4. 输出：`合并：{sources 列表} → {target}`

**`ARCHIVE`**：归档文档

1. 创建 `docs/_archive/` 目录（若不存在）
2. 将文件移入归档目录
3. 输出：`归档：{path} → {archive_path}`

**`UPDATE_REFS`**：更新引用路径

1. 读取目标文件
2. 将旧引用路径替换为新路径
3. 写回文件
4. 输出：`更新引用：{file} 中 {old_ref} → {new_ref}`

---

**内容操作**（新增）：

**`UPDATE_SECTION`**：更新文档中特定章节的内容

1. 读取目标文件
2. 定位目标章节（按 H2 标题匹配）
3. 将旧章节内容替换为 Skill 提供的新内容
4. 写回文件
5. 输出：`内容更新：{file} 的「{section_title}」章节`

> 若找不到目标章节，在完成摘要中标注，不报错终止。

**`CREATE_FILE`**：创建新文档（填补知识缺口）

1. 按 Skill 提供的路径、大纲和初始内容创建新文件
2. 输出：`新建：{path}（{reason}）`

**`SYNC_CONCEPT`**：跨文档同步概念定义

1. 确定权威定义来源（Skill 指定）
2. 在各目标文档中定位该概念的旧定义/使用处
3. 更新为统一的表述
4. 输出：`同步概念「{concept}」：更新 {N} 处（{文件列表}）`

---

**索引操作**（最后执行）：

**`UPDATE_INDEX`**：更新 index.md

1. 将 Skill 输出的新 index.md 内容写入 `docs/index.md`
2. 输出：`已更新 docs/index.md`

---

每个操作执行后输出进度：

```
[{当前操作序号}/{总操作数}] {操作类型}：{操作摘要}
```

---

### 阶段 5：输出完成摘要

```
---

文档库演进完成！

📊 **执行摘要**：
- 创建目录：{N} 个
- 移动文件：{N} 个
- 拆分文件：{N} 个
- 合并文件：{N} 组
- 归档文件：{N} 个
- 更新引用：{N} 处
- 更新章节内容：{N} 处
- 新建文档：{N} 篇
- 同步概念定义：{N} 项
- 更新 index.md：✓

📌 **建议后续操作**：
- 查看 `docs/index.md` 确认文档地图准确性
- 使用 `/review` 检查受影响文档的内容质量
- 若需继续调整，再次使用 `/evolve`
```

---

## 错误处理

| 错误场景 | 处理方式 |
|---------|---------|
| `docs/` 目录不存在 | 提示用户先使用 `/create` 创建文档 |
| `docs/index.md` 不存在 | 自动创建初始 index.md（仅含文件列表），继续流程 |
| 移动文件时目标路径已存在同名文件 | 使用 `question` 工具询问用户：覆盖 / 重命名 / 跳过 |
| `UPDATE_SECTION` 找不到目标章节 | 跳过该操作，在完成摘要中标注，提示用户手动处理 |
| `SYNC_CONCEPT` 找不到概念使用处 | 跳过该文档，继续其他目标文件 |
| 文档数量过多导致全文内容超长 | 优先读取方向偏离文档和核心文档，其余按"H2首段"策略摘要 |
| `doc-tree-evolve` Skill 输出操作引用了不存在文件 | 跳过该操作，在完成摘要中标注 |
| 用户意图过于模糊 | Skill 基于诊断结果提出 2-3 个具体方案，使用 `question` 工具让用户选择 |

---

## 流程图

```
/evolve <意图>
    │
    ▼
[阶段 0] 获取演进意图
    │ 若意图为空 → question 工具提供选项 → 追问细节
    ▼
[阶段 1] 全库深度扫描
    │ 1.1 元数据扫描（路径/行数/H1/H2/引用关系）
    │ 1.2 读取所有文档全文 → doc_contents
    │ 1.3 提取知识特征（概念/方向对齐/一致性/陈旧度）
    │ 1.4 结构诊断（超长/孤立/断裂/未收录）
    │ 1.5 读取 index.md 基准方向
    │ 1.6 输出扫描摘要
    ▼
[阶段 2] 调用 doc-tree-evolve Skill
    │ 传入：tree_snapshot + doc_contents + current_index + intent
    │ 输出：结构化变更计划（结构操作 + 内容操作）+ 新 index.md 草稿
    ▼
[阶段 3] 展示变更计划 → question 工具确认
    │   ├─ 全部执行 → 阶段 4
    │   ├─ 仅结构操作 → 过滤内容操作 → 阶段 4
    │   ├─ 仅低风险 → 过滤后 → 阶段 4
    │   └─ 放弃 → 输出"已取消"，终止
    ▼
[阶段 4] 按序执行操作
    │ 结构操作：CREATE_DIR → MOVE/SPLIT/MERGE/ARCHIVE → UPDATE_REFS
    │ 内容操作：UPDATE_SECTION / CREATE_FILE / SYNC_CONCEPT
    │ 最后：UPDATE_INDEX
    │ 每步输出进度
    ▼
[阶段 5] 输出完成摘要
```

---

## 注意事项

1. **全库视角**：始终以整个文档库为单位思考，不局限于单个文档
2. **内容第一**：方向变化时，优先更新相关文档的内容，再考虑结构调整
3. **概念一致性**：同一术语在全库中只应有一个权威定义，SYNC_CONCEPT 操作确保一致
4. **确认优先**：所有操作前必须通过阶段 3 获得用户确认，不得跳过
5. **拆分留链接**：拆分文档时，在原位置留下导航文件，链接指向各子文件
6. **移动更新引用**：移动文件时，必须更新所有引用该文件的其他文档中的路径
7. **归档不删除**：归档操作将文件移入 `docs/_archive/`，不物理删除
8. **index 最后更新**：所有文件操作和内容操作完成后才重新生成 index.md
9. **幂等设计**：多次对同一棵树执行 `/evolve` 应产生一致的结果
