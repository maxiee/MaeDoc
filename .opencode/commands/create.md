---
name: create
description: 一键创建新文档——MaeDoc 最核心的用户入口。与用户简短对话，AI 根据内容性质自主判断文档结构，直接生成并落盘，后续可通过 /iterate 持续演化。
---

# /create 命令

> **命令**：`/create`
> **版本**：2.0.0
> **用途**：从用户的一句话描述，自由创建结构化文档——AI 根据内容自主决定结构，不套模板

---

## 用法

```
/create <文档想法描述>
```

**示例**：

```
/create 我想整理一下对分布式系统 CAP 理论的理解
/create 记录今天关于微服务拆分的架构决策
/create 写一篇介绍 Rust 所有权机制的文章
```

---

## 交互原则

> **重要**：所有需要向用户提问或确认的步骤，**必须使用 `question` 工具**进行交互，而非直接输出文本等待用户回复。`question` 工具能在不退出当轮对话的情况下收集用户输入，保持流程连续性。

---

## 文件优先原则

> **核心设计**：从大纲阶段开始，**每一步的输出都直接写入磁盘文件**。各阶段 Skill 对同一个文件进行修改，而非在上下文中积累内容最后一次性落盘。这样用户可以在创建过程中随时查看文件的当前状态。

---

## 执行流程

### 阶段 0：准备

1. 从 `/create` 命令参数中提取用户的想法描述（即 `<文档想法描述>`）
2. 若用户未提供描述（即直接输入 `/create` 无参数），使用 `question` 工具提问：
   - **问题**：你想写什么文档？
   - **选项**：用户自由输入（可提示示例：对某个概念的理解整理、架构决策记录、技术调研笔记等）

   收到回答后继续后续步骤。

---

### 阶段 0.5：深化需求探询

> **目标**：在生成大纲之前，通过简短对话充分了解用户需求，积累的问答记录将作为 `enriched_context` 传入后续阶段。

**执行规则**：

1. 基于用户的初始描述，推断出最有价值的第一个追问（例如：目标读者是谁、核心诉求是什么、有哪些已知限制等）。
2. 使用 `question` 工具提出问题，**选项列表的最后一项始终保留**：
   - `已经足够了，开始生成大纲`（终止选项）
3. 若用户**未选择**终止选项：
   - 记录本轮问答（`Q: {问题} / A: {回答}`）
   - 根据已有回答推断下一个最有价值的追问，再次调用 `question` 工具（仍保留终止选项）
   - 如此循环，**无次数上限**，直到用户主动终止
4. 若用户**选择**终止选项：
   - 将本轮所有问答汇总为 `enriched_context`，格式如下：

     ```
     原始描述：{用户最初的想法}

     补充信息：
     - Q: {问题1} → A: {回答1}
     - Q: {问题2} → A: {回答2}
     …
     ```

   - 继续阶段 1，后续所有阶段使用 `enriched_context` 替代单纯的原始描述

**追问方向参考**（根据内容和已有信息灵活选择，不必按顺序）：

| 维度 | 示例问题 |
|------|---------|
| 目标读者 | 这篇文档主要写给谁看？（自己备忘 / 团队内部 / 外部读者） |
| 核心目标 | 你最希望读者读完后能得到什么？ |
| 内容边界 | 有哪些内容**一定要包含**？有哪些**不需要覆盖**？ |
| 已有素材 | 你有现成的草稿、参考资料或要点可以提供吗？ |
| 风格偏好 | 偏好正式严谨的技术风格，还是轻松易读的风格？ |
| 长度预期 | 期望文档大概多长？（简短摘要 / 中等篇幅 / 详尽全面） |
| 特殊约束 | 有没有格式、语言或发布平台方面的限制？ |

> **注意**：每次追问应优先选择在当前上下文中信息增益最大的维度，避免重复提问已明确的内容。

---

### 阶段 1：确定输出文件路径

> **重要**：在生成大纲之前先确定文件路径，后续所有阶段都对同一文件进行读写操作。

**步骤 1.1：生成文件名**

基于以下规则生成文件名：

1. 根据用户描述中的关键词，生成语义化英文文件名（kebab-case）
   - 中文描述：提取核心主题词，转为英文或拼音缩写
   - 示例：「分布式系统 CAP 理论」→ `cap-theorem-notes.md`
2. 若无法提取有效关键词：使用 `doc-{当前日期 YYYYMMDD}.md`
   - 示例：`doc-20240115.md`
3. 若文件名已存在：追加序号后缀，如 `cap-theorem-notes-2.md`

**步骤 1.2：确认 docs/ 目录**

检查 `docs/` 目录是否存在：
- 若不存在：使用 `question` 工具询问用户是否创建该目录，确认后创建
- 若已存在：直接使用

**步骤 1.3：路径深度判断**

基于 `enriched_context`，判断新文档是否属于某个已有分类：

1. 读取 `docs/index.md` 的文档地图，获取现有分类列表
2. 若能识别出文档属于某个已有分类（如该分类已有对应子目录），路径使用子目录：
   - 示例：文档关于 CAP 理论，已有 `docs/distributed-systems/` 目录 → `docs/distributed-systems/cap-theorem.md`
3. 若无法归入已有分类，放在 `docs/` 根目录

**步骤 1.4：记录输出路径**

将 `output_file = docs/{文件名}` 作为变量，在后续所有阶段中引用。输出告知用户：

```
📁 文档将保存至：docs/{文件名}
```

---

### 阶段 2：大纲生成

**步骤 2.1：调用 `doc-outline-generate` Skill**

加载 `doc-outline-generate` Skill，传入以下参数：

- `idea`：阶段 0.5 汇总的 `enriched_context`（包含原始描述 + 所有追问回答）；若用户跳过追问则使用原始描述
- `extra_constraints`：（如有）用户在描述或追问回答中提到的额外约束
- `output_file`：阶段 1 确定的文件路径

> **注意**：AI 根据内容的性质自主决定文档结构，不依赖预设模板。思考"这份内容最适合什么形式呈现"，而非"套用哪个模板"。

执行大纲生成。**`doc-outline-generate` 会在生成大纲后立即将大纲内容写入 `output_file`**，无需本命令再次写入。

**步骤 2.2：大纲交互确认**

大纲生成并写入文件完毕后，使用 `question` 工具呈现大纲并请求确认：

- **标题**：确认文档大纲
- **问题**：大纲已生成并保存至 `{output_file}`（见上方输出），请选择下一步操作：
- **选项**：
  1. 确认大纲，开始填充内容（Recommended）
  2. 修改大纲（请在选择后说明需要调整的内容）
  3. 重新生成大纲（请在选择后补充更多背景信息）
  4. 放弃

根据用户回应：

- **选择 1（确认）**：继续阶段 3
- **选择 2（修改）**：收集用户修改意见，更新大纲，将修改后的大纲重新写入 `output_file`，再次使用 `question` 工具确认
- **选择 3（重新生成）**：使用 `question` 工具收集更多背景信息，重新调用 `doc-outline-generate`（附带 `output_file`），再次确认
- **选择 4（放弃）**：输出 `已取消文档创建流程。` 并终止

---

### 阶段 3：内容填充

**步骤 3.1：调用 `doc-content-fill` Skill**

加载 `doc-content-fill` Skill，传入以下参数：

- `output_file`：阶段 1 确定的文件路径（Skill 从此文件读取大纲，并逐章节将内容写回此文件）
- `materials`：用户在对话中提供的任何素材（背景资料、数据、代码片段等）
- `constraints`：用户指定的额外约束（语言风格、目标长度等）

**`doc-content-fill` 直接操作 `output_file`**：从文件读取大纲，逐章节填充内容后写回文件，文件在此过程中持续更新。

**步骤 3.2：内容填充进度提示**

每开始填充一个章节时，输出进度提示：

```
正在填充：## {章节标题}（{当前章节序号}/{总章节数}）→ 已写入 {output_file}
```

---

### 阶段 4：格式规范化

**步骤 4.1：调用 `doc-format-normalize` Skill**

加载 `doc-format-normalize` Skill，传入以下参数：

- `document`：`output_file`（文件路径，Skill 直接读取并写回该文件）
- `dry_run`：`false`（直接修改文件，不是预览）

**`doc-format-normalize` 直接读取 `output_file`，完成格式修正后写回同一文件**。

---

### 阶段 5：输出完成摘要

> 此时 `output_file` 已包含完整的、格式规范的文档内容。

**步骤 5.1：输出完成摘要**

```
---

文档创建完成！

📄 **文件路径**：`docs/{文件名}`
📊 **文档概况**：共 {N} 个章节，约 {N} 字

**各章节信心等级**：
{从填充摘要中提取的信心等级表}

**遗留待确认项**（共 {N} 项）：
{从填充摘要中提取的待确认项列表，若无则显示"无"}

---

📌 **建议后续操作**：
- 使用 `/review docs/{文件名}` 进行全面审阅
- 使用 `/iterate docs/{文件名} <反馈>` 进行定向优化
```

---

### 阶段 6：更新 docs/index.md

> 将新创建的文档登记到入口文档的文档地图中。

**步骤 6.1：读取当前 index.md**

读取 `docs/index.md` 的完整内容。若 `docs/index.md` 不存在，使用初始模板创建。

**步骤 6.2：追加到文档地图**

1. 根据文档内容判断应归入哪个分类
2. 若文档地图中已有匹配的分类，在该分类表格末尾追加一行：
   ```markdown
   | [文档标题](./相对路径) | 一句话描述 |
   ```
3. 若无匹配分类，创建新的分类标题（H3）并添加条目
4. 更新目录结构树

**步骤 6.3：写回 index.md**

将更新后的内容写回 `docs/index.md`，更新末尾的最后更新时间。

输出：

```
已将 docs/{文件名} 添加到 docs/index.md 文档地图。
```

---

## 错误处理

| 错误场景 | 处理方式 |
|---------|---------|
| 大纲生成失败（Skill 执行异常） | 提示异常原因，建议补充更多背景信息后重试 |
| `docs/` 目录不存在 | 使用 `question` 工具询问用户是否创建该目录，确认后创建再写入 |
| 文件写入被拒绝（权限） | 提示权限错误，建议检查 `opencode.jsonc` 的 `permission.edit` 配置 |
| 大纲写入文件后用户放弃 | 删除已创建的文件，或保留（由用户选择） |

---

## 流程图

```
/create <描述>
    │
    ▼
[阶段 0] 提取用户描述
    │ 若描述为空 → 使用 question 工具提问 → 收到回答后继续
    ▼
[阶段 0.5] 深化需求探询（持续追问循环）
    │ question 工具提问（末尾保留"已经足够了，开始生成大纲"选项）
    │   ├─ 用户未选终止 → 记录问答 → 推断下一追问 → 继续循环
    │   └─ 用户选终止  → 汇总 enriched_context → 继续
    ▼
[阶段 1] 确定输出文件路径 → 创建 docs/ 目录（如需）→ 判断路径深度（归入已有分类或根目录）→ 告知用户文件路径
    │
    ▼
[阶段 2] doc-outline-generate（传入 enriched_context，AI 自主决定结构）→ 写入 output_file → 用户确认
    │ 确认 / 修改（重新写入文件）/ 重新生成（重新写入文件）
    ▼
[阶段 3] doc-content-fill → 从 output_file 读取大纲 → 逐章节填充 → 逐章节写回 output_file
    │
    ▼
[阶段 4] doc-format-normalize → 读取 output_file → 格式修正 → 写回 output_file
    │
    ▼
[阶段 5] 输出完成摘要（文件已就绪）
    │
    ▼
[阶段 6] 更新 docs/index.md → 读取 index → 追加文档地图条目 → 写回 index
```

---

## 注意事项

1. **文件优先**：`output_file` 在阶段 1 确定后贯穿全流程，所有 Skill 都操作同一文件
2. **交互优先**：大纲确认等关键决策节点必须等待用户响应，不得跳过
3. **不阻塞原则**：大纲和内容中的未知信息用 `[待确认: ...]` 占位，不因信息缺失而暂停整个流程
4. **权限意识**：写入 `docs/` 目录前，遵循 `opencode.jsonc` 中 `edit` 权限配置；若需要询问，先询问再执行
5. **幂等设计**：若目标文件已存在，不直接覆盖，改用带序号的新文件名，并告知用户
6. **自由结构**：AI 根据内容自主判断最合适的文档结构，不依赖预设模板；同一个 `/create` 命令对不同主题可能产生完全不同的章节组织
