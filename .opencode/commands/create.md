---
name: create
description: 一键创建新文档——MaeDoc 最核心的用户入口。解析用户意图，匹配文档类型，通过大纲确认和内容填充流程，所有中间产物直接落盘到文件，后续每一步对磁盘文件进行修改，直到最终完成。
---

# /create 命令

> **命令**：`/create`
> **版本**：1.1.0
> **用途**：一键启动文档创建流水线，从用户的一句话想法到完整的结构化文档

---

## 用法

```
/create <文档想法描述>
```

**示例**：

```
/create 我想写一篇关于微服务架构的技术设计文档
/create 帮我写一篇介绍 Rust 所有权机制的博客文章
/create 写一个通用文档，记录我们团队的 API 设计规范
```

---

## 交互原则

> **重要**：在整个流程中，所有需要向用户提问或确认的步骤，**必须使用 `question` 工具**进行交互，而非直接输出文本等待用户回复。`question` 工具能在不退出当轮对话的情况下收集用户输入，保持流程连续性。

---

## 文件优先原则

> **核心设计**：从大纲阶段开始，**每一步的输出都直接写入磁盘文件**。各阶段 Skill 对同一个文件进行修改，而非在上下文中积累内容最后一次性落盘。这样用户可以在创建过程中随时查看文件的当前状态。

---

## 执行流程

### 阶段 0：准备

1. 从 `/create` 命令参数中提取用户的想法描述（即 `<文档想法描述>`）
2. 若用户未提供描述（即直接输入 `/create` 无参数），使用 `question` 工具提问：
   - **问题**：你想写什么文档？
   - **选项**：用户自由输入（可提示示例：技术设计文档、博客文章、通用文档等）

   收到回答后继续后续步骤。

---

### 阶段 1：文档类型匹配

**步骤 1.1：扫描可用文档类型**

读取以下目录下所有文档类型定义：

```
docs/_templates/*/type.json
```

提取每个类型的 `type_id`、`name`、`description`、`tags` 字段，构建可用类型列表。

**步骤 1.2：意图分析与类型匹配**

基于用户描述，分析意图并匹配最合适的文档类型：

| 意图特征 | 匹配类型 |
|---------|---------|
| 包含"技术设计"、"架构"、"方案"、"系统设计"、"Tech Design" | `tech-design` |
| 包含"博客"、"文章"、"科普"、"教程"、"Blog" | `blog-post` |
| 其他（无法明确匹配特定类型时） | `generic` |

**步骤 1.3：向用户确认文档类型**

使用 `question` 工具确认文档类型：

- **标题**：选择文档类型
- **问题**：根据你的描述，我建议使用「{类型名称}」（`{type_id}`）——{类型描述}。请确认或选择其他类型：
- **选项**：
  - 使用推荐类型「{类型名称}」（Recommended）
  - {列出其他可用类型，每种作为一个选项，格式：类型名称（type_id）- 一句话描述}

根据用户回答更新 `doc_type`，然后继续。

---

### 阶段 1.5：确定输出文件路径

> **重要**：在生成大纲之前先确定文件路径，后续所有阶段都对同一文件进行读写操作。

**步骤 1.5.1：生成文件名**

基于以下规则生成文件名：

1. 根据用户描述中的关键词，生成语义化英文文件名（kebab-case）
   - 中文描述：提取核心主题词，转为英文或拼音缩写
   - 示例：「微服务架构迁移设计」→ `microservice-migration-design.md`
2. 若无法提取有效关键词：使用 `{type_id}-{当前日期 YYYYMMDD}.md`
   - 示例：`tech-design-20240115.md`
3. 若文件名已存在：追加序号后缀，如 `tech-design-20240115-2.md`

**步骤 1.5.2：确认 docs/ 目录**

检查 `docs/` 目录是否存在：
- 若不存在：使用 `question` 工具询问用户是否创建该目录，确认后创建
- 若已存在：直接使用

**步骤 1.5.3：记录输出路径**

将 `output_file = docs/{文件名}` 作为变量，在后续所有阶段中引用。输出告知用户：

```
📁 文档将保存至：docs/{文件名}
```

---

### 阶段 2：大纲生成

**步骤 2.1：调用 `doc-outline-generate` Skill**

加载 `doc-outline-generate` Skill，传入以下参数：

- `idea`：用户的想法描述
- `doc_type`：已确认的文档类型 `type_id`
- `extra_constraints`：（如有）用户在描述中提到的额外约束
- `output_file`：阶段 1.5 确定的文件路径

执行大纲生成。**`doc-outline-generate` 会在生成大纲后立即将大纲内容写入 `output_file`**，无需本命令再次写入。

**步骤 2.2：大纲交互确认**

大纲生成并写入文件完毕后，使用 `question` 工具呈现大纲并请求确认：

- **标题**：确认文档大纲
- **问题**：大纲已生成并保存至 `{output_file}`（见上方输出），请选择下一步操作：
- **选项**：
  1. 确认大纲，开始填充内容（Recommended）
  2. 修改大纲（请在选择后说明需要调整的内容）
  3. 重新生成大纲（请在选择后补充更多背景信息）
  4. 放弃

根据用户回应：

- **选择 1（确认）**：继续阶段 3
- **选择 2（修改）**：收集用户修改意见，更新大纲，将修改后的大纲重新写入 `output_file`，再次使用 `question` 工具确认
- **选择 3（重新生成）**：使用 `question` 工具收集更多背景信息，重新调用 `doc-outline-generate`（附带 `output_file`），再次确认
- **选择 4（放弃）**：输出 `已取消文档创建流程。` 并终止

---

### 阶段 3：内容填充

**步骤 3.1：调用 `doc-content-fill` Skill**

加载 `doc-content-fill` Skill，传入以下参数：

- `output_file`：阶段 1.5 确定的文件路径（Skill 从此文件读取大纲，并逐章节将内容写回此文件）
- `doc_type`：文档类型 `type_id`
- `materials`：用户在对话中提供的任何素材（背景资料、数据、代码片段等）
- `constraints`：用户指定的额外约束（语言风格、目标长度等）

**`doc-content-fill` 直接操作 `output_file`**：从文件读取大纲，逐章节填充内容后写回文件，文件在此过程中持续更新。

**步骤 3.2：内容填充进度提示**

每开始填充一个章节时，输出进度提示：

```
正在填充：## {章节标题}（{当前章节序号}/{总章节数}）→ 已写入 {output_file}
```

---

### 阶段 4：格式规范化

**步骤 4.1：调用 `doc-format-normalize` Skill**

加载 `doc-format-normalize` Skill，传入以下参数：

- `document`：`output_file`（文件路径，Skill 直接读取并写回该文件）
- `dry_run`：`false`（直接修改文件，不是预览）

**`doc-format-normalize` 直接读取 `output_file`，完成格式修正后写回同一文件**。

---

### 阶段 5：输出完成摘要

> 此时 `output_file` 已包含完整的、格式规范的文档内容。

**步骤 5.1：输出完成摘要**

```
---

文档创建完成！

📄 **文件路径**：`docs/{文件名}`
📋 **文档类型**：{类型名称}（`{type_id}`）
📊 **文档概况**：共 {N} 个章节，约 {N} 字

**各章节信心等级**：
{从填充摘要中提取的信心等级表}

**遗留待确认项**（共 {N} 项）：
{从填充摘要中提取的待确认项列表，若无则显示"无"}

---

📌 **建议后续操作**：
- 使用 `/review docs/{文件名}` 进行全面审阅
- 使用 `/iterate docs/{文件名} <反馈>` 进行定向优化
- 使用 `/audit docs/{文件名}` 运行质量全套检查
```

---

## 错误处理

| 错误场景 | 处理方式 |
|---------|---------|
| `docs/_templates/` 目录不存在或无任何 `type.json` | 提示"未找到文档类型定义，请确认 MaeDoc 仓库结构完整"，终止流程 |
| 指定的 `type_id` 不存在 | 使用 `question` 工具列出可用类型供用户重新选择 |
| 大纲生成失败（Skill 执行异常） | 提示异常原因，建议补充更多背景信息后重试 |
| `docs/` 目录不存在 | 使用 `question` 工具询问用户是否创建该目录，确认后创建再写入 |
| 文件写入被拒绝（权限） | 提示权限错误，建议检查 `opencode.jsonc` 的 `permission.edit` 配置 |
| 大纲写入文件后用户放弃 | 删除已创建的文件，或保留（由用户选择） |

---

## 流程图

```
/create <描述>
    │
    ▼
[阶段 0] 提取用户描述
    │ 若描述为空 → 使用 question 工具提问 → 收到回答后继续
    ▼
[阶段 1] 扫描可用文档类型 → 意图匹配 → 确认文档类型
    │ 用户确认 / 选择其他类型
    ▼
[阶段 1.5] 确定输出文件路径 → 创建 docs/ 目录（如需）→ 告知用户文件路径
    │
    ▼
[阶段 2] doc-outline-generate → 输出大纲 → 立即写入 output_file → 用户确认
    │ 确认 / 修改（重新写入文件）/ 重新生成（重新写入文件）
    ▼
[阶段 3] doc-content-fill → 从 output_file 读取大纲 → 逐章节填充 → 逐章节写回 output_file
    │
    ▼
[阶段 4] doc-format-normalize → 读取 output_file → 格式修正 → 写回 output_file
    │
    ▼
[阶段 5] 输出完成摘要（文件已就绪）
```

---

## 注意事项

1. **文件优先**：`output_file` 在阶段 1.5 确定后贯穿全流程，所有 Skill 都操作同一文件
2. **交互优先**：每个关键决策节点（类型确认、大纲确认）必须等待用户响应，不得跳过
3. **不阻塞原则**：大纲和内容中的未知信息用 `[待确认: ...]` 占位，不因信息缺失而暂停整个流程
4. **权限意识**：写入 `docs/` 目录前，遵循 `opencode.jsonc` 中 `edit` 权限配置；若需要询问，先询问再执行
5. **幂等设计**：若目标文件已存在，不直接覆盖，改用带序号的新文件名，并告知用户
6. **上下文携带**：整个流程在同一会话上下文中执行，各阶段的中间产物（大纲、填充摘要）在后续阶段中可引用
